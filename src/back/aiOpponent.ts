import {
  GROUND_HEIGHT,
  EDGE_HEIGHT,
  PADDLE_STEP,
  PADDLE_MIN_Z,
  PADDLE_MAX_Z,
  UP,
  DOWN,
  STOP
} from "../defines/constants";

import type { MeshPositions, PlayerInput, /*User,*/ Game/*, GUID*/ } from "../defines/types";
import { Vector3 } from "@babylonjs/core/Maths/math.vector";
// import { generateGuid } from '../helpers/helpers';

interface AIOpponentConfig {
  paddleSpeed: number; // –°–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è —Ä–∞–∫–µ—Ç–∫–∏ (–µ–¥–∏–Ω–∏—Ü –≤ —Å–µ–∫—É–Ω–¥—É)
  updateInterval: number; // –ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è (–≤ –º—Å, 1000 = 1 —Å–µ–∫)
}

export class AIOpponent {
  //private user = Math.random().toString(36).substring(2, 15);
  private game: Game; // –¢–µ–∫—É—â–∞—è –∏–≥—Ä–∞
  private config: AIOpponentConfig;
  private lastUpdate: number = 0; // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
  private ballVelocity: Vector3 = new Vector3(0, 0, 0); // –°–∫–æ—Ä–æ—Å—Ç—å –º—è—á–∞
  private lastBallPosition: Vector3 | null = null; // –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–∑–∏—Ü–∏—è –º—è—á–∞

  constructor(game: Game) {
    //this.user;
    this.game = game;
    this.config = {
      paddleSpeed: PADDLE_STEP,
      updateInterval: 100, // üëø 1000 !!!!!!!!!!!!!!!
    };
  }

  update(positions: MeshPositions, currentTime: number): PlayerInput | null {
    if (currentTime - this.lastUpdate < this.config.updateInterval) {
      // console.log(`[${currentTime}] Update skipped: too early`);
      return null; // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
    }
    this.lastUpdate = currentTime;

    if (this.lastBallPosition) {
      const deltaTime = this.config.updateInterval / 1000; // –í—Ä–µ–º—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
      this.ballVelocity = positions.ball
        .subtract(this.lastBallPosition)
        .scale(1 / deltaTime);
      console.log(`[${currentTime}] Ball velocity: x=${this.ballVelocity.x}, y=${this.ballVelocity.y}`);
    } else {
      /* –î–ª—è –ø–µ—Ä–≤–æ–≥–æ —à–∞–≥–∞ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –º—è—á –¥–≤–∏–∂–µ—Ç—Å—è –∫ AI */
      const paddleZ = positions.paddleRight.z;
      this.ballVelocity = new Vector3(5, 0, positions.ball.z - paddleZ);

      console.log(`[${currentTime}] Initial ball velocity: x=${this.ballVelocity.x}, y=${this.ballVelocity.y}`);
    }
    this.lastBallPosition = positions.ball.clone();

    /* –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º, –≥–¥–µ –º—è—á –ø–µ—Ä–µ—Å–µ—á–µ—Ç –ª–∏–Ω–∏—é —Ä–∞–∫–µ—Ç–∫–∏ */
    const predictedZ = this.predictBallPosition(positions);
    const paddleZ = positions.paddleRight.z;
    console.log(`[${currentTime}] Predicted Z: ${predictedZ}`);
    console.log(`[${currentTime}] Paddle Z: ${paddleZ}`);

    /* –õ–æ–≥–∏–∫–∞ –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏—è */
    const threshold = 0.5; // –î–æ–ø—É—Å—Ç–∏–º–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ

    let direction: typeof UP | typeof DOWN | typeof STOP = STOP;

    // if (predictedZ > paddleZ + threshold) direction = UP;
    // else if (predictedZ < paddleZ - threshold) direction = DOWN;

    if (predictedZ < paddleZ - threshold) direction = UP;
    else if (predictedZ > paddleZ + threshold) direction = DOWN;

    if (direction !== STOP) {
      return {
        type: "PlayerInput",
        side: "right",
        gameId: this.game.id,
        direction,
      };
    }
    return null;
  }
    /* –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º, –≥–¥–µ –º—è—á –ø–µ—Ä–µ—Å–µ—á–µ—Ç –ª–∏–Ω–∏—é —Ä–∞–∫–µ—Ç–∫–∏ */

  private predictBallPosition(positions: MeshPositions): number {
  const ball = positions.ball;
  const paddleX = positions.paddleRight.x;

  console.log(`[${this.lastUpdate}] Ball position: x=${ball.x}, y=${ball.y}`);
  console.log(`[${this.lastUpdate}] Paddle X: ${paddleX}, Velocity X: ${this.ballVelocity.x}`);

  /* –ï—Å–ª–∏ –º—è—á –¥–≤–∏–∂–µ—Ç—Å—è –≤ —Å—Ç–æ—Ä–æ–Ω—É AI */
  if (this.ballVelocity.x > 0) {
    const distanceToPaddle = Math.abs(paddleX - ball.x);
    const timeToPaddle = this.ballVelocity.x !== 0
        ? distanceToPaddle / /*Math.abs(*/this.ballVelocity.x/*)*/
        : Infinity;
    console.log(`[${this.lastUpdate}] Time to paddle: ${timeToPaddle}`);

    if (timeToPaddle === Infinity || timeToPaddle <= 1) {
      console.log(
        `[${this.lastUpdate}] Ball close or infinite time, using current ball Y: ${ball.y}`
      );
      return ball.z;
    }

    /* –†–∞—Å—á—ë—Ç Y —Å —É—á—ë—Ç–æ–º –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ—Ç—Ä–∞–∂–µ–Ω–∏–π –æ—Ç –≤–µ—Ä—Ö–Ω–µ–≥–æ –∏ –Ω–∏–∂–Ω–µ–≥–æ –∫—Ä–∞—è */
    const upperBound = GROUND_HEIGHT / 2 - EDGE_HEIGHT;
    const lowerBound = -GROUND_HEIGHT / 2 + EDGE_HEIGHT;


    let predictedZ = ball.z + this.ballVelocity.z * timeToPaddle;

        /* –ª–æ–≥–∏–∫–∞ –æ—Ç—Ä–∞–∂–µ–Ω–∏—è –æ—Ç –≥—Ä–∞–Ω–∏—Ü */
    const fieldHeight = upperBound - lowerBound;
    const offset = predictedZ - lowerBound;

    const bounces = Math.floor(offset / fieldHeight);
    const remainder = offset % fieldHeight;

    if (bounces % 2 === 0) {
      predictedZ = lowerBound + remainder;
    } else {
      predictedZ = upperBound - remainder;
    }
    /* –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ø–æ–ª—è */
    if (predictedZ > PADDLE_MAX_Z) predictedZ = PADDLE_MAX_Z;
    if (predictedZ < PADDLE_MIN_Z) predictedZ = PADDLE_MIN_Z;

    console.log(`[${this.lastUpdate}] Predicted Z (clamped): ${predictedZ}`);
    return predictedZ;
  }

  console.log(`[${this.lastUpdate}] Ball moving away, returning paddle`);
  return positions.paddleRight.z;
}

  usePowerUp(): PlayerInput | null {
    return null; // üí•üí•üí•–ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è power-up
  }
}

//   getUser(): User {
//     return this.user;
//   }
// }
