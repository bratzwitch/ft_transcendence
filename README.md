# Привет, лунатики!


### Как запустить

* Скачать репозиторий =)
* добавить в корень проекта .env файл, за содержимым - к Максу
* для двухфакторной авторизации нужно установить на телефон Google Authentificator ( https://apps.apple.com/us/app/google-authenticator/id388497605	/	https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2 ), этим приложением отсканировать qr код ./data/OTP/QR.png, он позволит проходить авторизацию с логином-паролем админа.
* `npm i`
* `npm run build`
* `npm start`

### Typescript

Тайпскрипт это надстройка над жаваскриптом, которая позволяет определять и контроллировать типы всего - от примитивных типов данных до классов и обьектов.

Есть стандартный компилятор (tsc), который просто стирает из текста все типы и получается, собственно, обычный жаваскрипт.

Есть инструменты типа ts-node, которые пережевывают тайпскрипт файлы на ходу, в рантайме, без создания .js файлов.

В любом случае тайпскрипт требует конфиг-файл - tsconfig.json, он лежит в корне проекта.
Там относителььно несложные параметры и есть комментарии из стандартного шаблона, можно поковырять.

Четыре важные настройки там это: target, module, moduleResolution и allowSyntheticDefaultImports.
Они определяют, какие правила импортов и экспортов и какие стандарты будут применяться при компиляции.
С ними черт ногу сломит, но вот так, как сейчас - работает =)

С импортами и экспортами - они как бы похожи на инклюды из С/С++ но, на самом деле, немного другая история, надо привыкнуть.

#### Важно понимать:
Все проверки типов существуют только пока файл - .ts

После компиляции в .js вся типизация исчезает, а жаваскрипт позовляет менять тип переменной на ходу и принимать, например, в качестве аргумента обьект любого типа,
лишь бы был объект.

Так что если кому-то захочется поиграть в сурьёзную рантайм валидацию - нужно прямо писать функцию, где проверяется наличие в объекте всех нужных полей, тут вам не С/С++.

### Webpack

Вебпак - это бандлер, инструмент, который, грубо говоря, запихивает твой большой проект в один файл. Это его базовая функция, но далеко не единственная.

Там тоже черт ногу сломит с настройками, сейчас используется два конфига - webpack.back.ts и webpack.front.ts, которые собирают каждый свою часть.
Они вызываются базовым конфигом, webpack.config.js, я не смог запихать его в тайпскрипт без неприятных танцев с бубнами.

Кроме компиляции .ts файлов он обрабатывает ассеты (картинки, например),
файлы со стилями (.css), динамически генерит финальный html файл для фронтенда и всякое такое.

Использовать бандлеры можно, я сверялся с несколькими темами в слаке, народ даже писал официальный запрос в Париж.
Чуть ниже опишу пару ситуаций, где может понадобиться редактировать конфиг.

### Fastify

Это, по сути, набор инструментов, которые позволяют быстро написать быстрый сервер =)

В этом проекте он нужен, чтобы не писать сервер на РНР, а чтобы вся наша тут история могла быть написана на одном языке и использовать без проблем общий код, общие константы итд.

Он бысрее своих конкурентов (например Express.js), по крайней мере на тестах, но не очень популярен. ХЗ почему.

Часть его скорости, как я понял - в его модульности. Ты подключаешь только те плагины, которые тебе нужны и все, что не нужно, соответственно - не жрет ресурсы.

Он сервит все файлы клиенту, обрабатывает вебсокеты для чата и игры, можно попробовать обращения к базе данных тоже сделать через него.
Там даже можно относительно легко настроить проксирование - но это скорее пригодится, когда/если будем распиливать проект на микросервисы.

### Babylon.js

Это библиотека для создания и отображения 3д-сцен. Сейчас она используется так - есть базовая сцена, где только описаны обьекты и их положение на сцене.

Потом от нее наследуются сцены отдельно для фронта и для бека. Можно поковырять src/scenes, там довольно понятно.
Сцена для фронта включает освещение, тени, (потом добавлю) текстуры, итд.
Сцена для бека сейчас бежит на так называемом NullEngine, он не занимается генерацией визуальной части, только высчитывает обьекты, коллизии физику итд.

Руководствуясь исключительно благими намерениями, я отнаследовал от класса NullEngine свой класс и постепенно, сам того не заметив, сделал из него god-object.
Там хранится всё - сцены, игроки, их состояния, всё.
Пока вроде удобно, но если партия скажет - я разделю на логические части или хотя бы не буду посылать в функции весь обьект, посмотрим.
Я думал, что камеру будет достаточно подключить только для фронт-сцены, но там так устроено, что без камеры (даже если она ничего и не показывает) движок не может считать сам тики (кадры, если угодно), так что камера ушла из фронтенда в базовую сцену.

Вообще библиотека очень мощная и можно в ней зафигачить очень серьезные вещи, но мне бы понимать, в какую сторону копать - неплохо бы иметь визуалььный референс, как для самой игры, так и для всего сайта целиком.

### Сборка

Для сборки и запуска используем пакетный менеджер, встроенный в экосистему Node.js - npm (node packe manager).
Node.js конфигурирует себя под текущий проект согласно файлу package.json, он лежит в корне проекта. Сейчас он супер-простой, но туда можно тоже напихать всякого.
Сначала устанавливаем зависимости (внешние библиотеки и инструменты, которые нужны для сборки проекта и последующего использования):

`npm install`
или
`npm i`.

Зависимости, указанные в файле скачаются и распакуются в папку node_modules.

Есть два вида зависимостей - devDependencies, которые нужны только в момент разработки и сборки;
и просто dependencies, которые нужны так или иначе в рантайме (то бишь во время исполнения программы).

Их можно установить отдельно:

`npm i -D` и `npm i --omit=dev`

Это пригодится для создания отдельных слоев в докере.
Можно еще поставить зависимости глобально - это значит, что они будут доступны во всей системе, не только в папке проекта, но нам это нафиг не надо, да и прямо на школьную машину глобально ничего не поставить -  нужен root.

Список установленных зависимостей можно вывести с помощью
`npm list`
или
`npm list global` если хочется посмотреть, что там установлено для всей системы.

Потом собираем проект:
`npm run build`
или
`npm run build:prod`.

Эти команды можно посмотреть, изменить или добавить свои в файле package.json. Обе вызывают вебпак в режиме разработки или продакшена соответсвенно.
Пока достаточно просто build.

И запускаем сервер:
`npm start`.

Пока все крутится на порту 12800, по-хорошему надо сделать .env файл, который не будет в репозитории или будет в докер-секретах или что-то такое, и считывать порт оттуда.

### Как добавить отдельный скрипт в html файл

Создаем .ts файл в ./src/front. Файл может использовать код из других файлов и вообще использовать все, что угодно, но он должен быть отдельной "точкой входа", то есть тем, с чего начинается вся логика конкретно этого элемента. В данный момент у нас точки входа четыре - языки, логин, игра и чат. Каждая отвечает за свой блок на странице и в данный момент не лезет в логику другой. Это, конечно, всегда можно исправить =)

Идем в файл ./webpack.front.ts, там находим часть с точками входа:\
`entry: {`\
	`"i18next": path.resolve(appDir, srcDir, frontDir, "i18next.ts"),`\
	`"login": path.resolve(appDir, srcDir, frontDir, "login.ts"),`\
	`"game": path.resolve(appDir, srcDir, frontDir, "game.ts"),`\
	`"chat": path.resolve(appDir, srcDir, frontDir, "chat.ts")`\
`},`

Добавляем туда по шаблону свой файл.

ГОТОВО, ВЫ ВЕЛИКОЛЕПНЫ! Файлик будет динамически добавлен в скрипты итогового html файла.

Вот  =)


Хотел написать больше, но допишу потом.
Держитесь, прорвёмся.
Макс

